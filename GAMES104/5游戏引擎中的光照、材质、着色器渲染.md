# 游戏引擎中的光照、材质、着色器渲染

## 渲染方程及挑战

### Kajiya 的 BRDF 渲染方程

radiance——辐射光强，irradiance——入射光强

$$
L_o(x,\omega_o) = L_e(x,\omega_o) + \int_{H^2} f_r(x,\omega_o,\omega_i) L_i(x,\omega_i) \cos \theta_i d \omega_i
$$

$L_o$：出射光强，$x$：渲染物体表面一点，$\omega_o$：出射角

$L_e$：辐射光强

$\int_{H^2}$：对上半球面积分，$f_r(x,\omega_o,\omega_i)$：散布函数

$L_i$：入射光强，$\omega_i$：入射角

$\theta_i$：入射角与法向夹角

## 简单的渲染模型

> ambient light + simple light = result
>
> 环境贴图反射 Environment Map Reflection

- Main Light：主光
- Ambient Light：模拟球面分布的低频入射环境光
- Environment Map：模拟球面分布的高频入射环境光

## Blinn-Phong 材质

Diffuse + Ambient + Specular = Blinn-Phong Reflection

### 问题

- 能量不保守（Not Energy Conservative），无法用于光线追踪
- 真实世界的复杂材质，难以用经验表达

## 阴影图 Shadow Map

### 原理

1. 从光源处渲染一张投影点到光源距离的深度图 $c$
2. 从摄像机处渲染，对摄像机视线中的每一点 $p_z$，向光源投影得到投影点 $(p_x,p_y)$
3. 比较 $p_z$到光源距离与深度图中 $c(p_x,p_y)$记录的到光源距离
4. 若 $p_z$离光源更远，则其处在阴影中

### 缺陷

- 阴影分辨率受限于材质
- 深度精度受限于材质

通常的 workaround：加 bias

导致结果：游戏中人物阴影与脚底不重合

## 预计算全局光照 Pre-computed Global Illumination

目标：在多项式时间内计算材质 BRDF 积分

解决手段：傅里叶变换 Fourier Transform，获得场景低频光照信息

球面调和函数 Spherical Harmonics：在球面上定义的傅里叶变换模拟，用于探针（Probe）

### 球面调和函数光照贴图 SH Lightmap

使用低面数代理几何体（low-poly proxy geometry），进行 UV 参数化展开

优点：
- 运行时高效
- 烘焙精细的环境漫反射（diffuse）细节

缺点：
- 计算时间长
- 只支持静态场景和光照
- 空间开销大

### 探针 Probe

- 光照探针 Light Probe

	难点：Light Probe 摆放位置，如何自动生成等

- 反射探针 Reflection Probe

	难点：需要高频信息，分辨率高，性能开销大

优点：
- 运行时高效
- 静态与动态物体都适用
- diffuse 和 specular 都能处理

缺点：
- 大量的 SH 光照探针，需要预计算
- 采样稀疏，无法处理 GI 的精细细节，如软阴影和重叠几何结构

## 基于物理的材质 Physical-Based Material

### 微表面理论 Microfacet Theory

核心思想：物体的光滑度由微表面上法向的聚集度决定

### 基于微表面的 BRDF 模型 BRDF Model Based on Microfacet

$$
\begin{aligned}
L_o(x,\omega_o) = L_e(x,\omega_o) + \int_{H^2} f_r(x,\omega_o,\omega_i) L_i(x,\omega_i) \cos \theta_i d \omega_i
\end{aligned}
$$
其中：
$$
\begin{aligned}
f_r = k_d f_{Lambert} + f_{CookTorrance}
\end{aligned}
$$
其中：
$$
\begin{aligned}
f_{Lambert} = \frac{c}{\pi} \qquad \text{漫反射 diffuse 部分}
\end{aligned}
$$
$$
f_{CookTorrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)} \qquad \text{高光 specular 部分}
$$
其中 D 为法向分布：
$$
NDF_{GGX}(n,h,\alpha)=\frac{\alpha^2}{\pi ((n \cdot h)^2(\alpha^2-1)+1)^2}, \quad \alpha \text{为材质的 roughness}
$$
G 为几何自遮挡：
$$
G_{Smith}(l,v)=G_{GGX}(l) \cdot G_{GGX}(v)
$$
$$
G_{GGX}(v)=\frac{n \cdot v}{(n \cdot v)(1 - k) + k}, \quad k=\frac{(\alpha + 1)^2}{8}, \quad \alpha \text{为材质的 roughness}
$$
F 为菲涅尔方程：
$$
F_{Schlick}(h,v,F_0)=F_0+(1-F_0)(1-(v \cdot h))^5, \quad F_0\text{为菲涅尔系数}
$$

### 常用的 BRDF 模型

- PBR Specular Glossiness 模型（SG）：灵活强大，容易出错
- PBR Metallic Roughness 模型（MR）：限制了 SG 模型可调参数范围，不易出错

## 基于图像的光照 Image-Based Lighting

Diffuse Irradiance Map + Specular Approximation（略）

详见 GAMES202

## 经典阴影解决方案 Classic Shadow Solution

级联阴影 Cascade Shadow：从摄像机视锥出发，根据距离采用不同采样精度的阴影图

优点：
- 阴影计算不易出错，从视角出发进行反走样
- 深度图生成快
- 效果较好

缺点：
- 高质量区域阴影几乎不可能实现
- 阴影不支持颜色，不支持半透明物体

### Percentage Closer Filter，PCF

### Percentage Closer Soft Shadow，PCSS

### Variance Soft Shadow Map，VSSM

基于切比雪夫不等式

## AAA Rendering 总结

Lightmap + Lightprobe

PBR + IBL

Cascade shadow + VSSM

⬆️ 5 年前的 3A 效果，可找工作（不是）

## 前沿高质量渲染技术

- 实时光线追踪 Real-Time Ray-Tracing
- 实时全局光照 Real-Time Global Illumination
	- Screen-space GI
	- SDF Based GI
	- Voxel-Based GI（SVOGI / VXGI）
	- RSM / RTX GI
- 更复杂材质模型
	- BSDF Hair（Strand-Based Hair）
	- BSSRDF
- 虚拟阴影贴图 Virtual Shadow Maps
- Uber Shader and Variants
- 跨平台着色器编译 Cross Platform Shader Compile

# 游戏中地形、大气、云的渲染

## 地形的几何

- 高度图 Height Map、等高线图 Contour Map
- Adaptive Mesh Tessellation（自适应望各细分）

优化的两个方向：
- 根据到摄像机的距离和 FoV 优化
- 视角空间的几何简化（与 ground truth 对比允许误差在一定范围内）（预计算）

### 实践中的算法

- Triangle-Based Subdivision（基于二叉树）
	- 适用于大规模地形渲染
	- 注意 Subdivision 中出现的 T-Junction 情况
- QuadTree-Based Subdivision（基于四叉树），实践中最常用
	- 四边形网格的 T-Junction 中，使用 Mesh LoD Stitching 方法，将 T-Junction 的顶点移动到相邻顶点消除 T-Junction
- Triangulated Irregular Network（TIN）

### 基于 GPU 的曲面细分 GPU-Based Tessellation

DX11 三部分：Hull Shader、Tessellator、Domain Shader

Mesh -> Triangle Patch Mesh -> Hull Shader -> Tessellator ->Tessellated Mesh -> Domain Shader -> Displaced Mesh

DX12 支持：Amplification Shader、Mesh Shader，Mesh Shader 代替上面 Hull Shader、Tessellator、Domain Shader

GPU-Based Tessellation 功能可以支持实时可变形地形 Real-Time Deformable Terrain（雪地、泥地效果）

全动态地形：体素化表达 Voxel-Based Representation
- **Marching Cube 算法**

## 地形的材质

地形材质 Terrain Materials
- Base Color + Normal + Roughness + Height

材质混合 Texture Splatting
- 使用高度图 + 透明度混合 Blending with Height

```HLSL
float3 blend(float4 texture1, float height1, float4 texture2, float height2){
	return height1 > height2 ? texture1.rgb : texture2.rgb;
}
```

- 带 Bias 的高度图 + 透明度混合

```HLSL
float3 blend(float4 texture1, float height1, float4 texture2, float height2){
	float bias = 0.2;
	float ma = max(texture1.a + height1, texture2.a + height2) - bias;
	float b1 = max(texture1.a + height1 - ma, 0);
	float b2 = max(texture2.a + height2 - ma, 0);
	return (texture1.rgb * b1 + texture2.rgb * b2)/(b1 + b2);
}
```

### Material Texture Array

作用：将大量不同地表材质集中存储在数组中

### 视差与凹凸贴图 Parallax and Displacement Mapping

视差贴图 Parallax Mapping：
- 从摄像机角度微调渲染的像素，达到立体凹凸效果
- 物体的边缘仍然是光滑无立体凹凸效果的

凹凸贴图 Displacement Mapping：
- 借助 GPU Tessellation，直接根据凹凸贴图改变网格 Mesh

### 虚拟纹理 Virtual Texture，VT

为了解决渲染每个像素都需要对非常多纹理贴图进行采样的问题而诞生，已经成为现代游戏引擎事实标准

- 构建一个虚拟的索引的纹理，存储整个场景的混合采样好的材质，并生成多级 mipmap
- 根据摄像机视角，加载需要的对应 LoD 的纹理块
- 将纹理块拼接称为物理纹理，存到显存

虚拟纹理实现 VT Implementation 的前沿技术：DirectStorage & DMA

### 浮点数精度误差解决

IEEE 754 Float 32bit 在实际游戏中大约只支持 2~3km 半径的坐标范围，否则产生严重抖动

解决方法：相对于相机的渲染 Camera-Relative Rendering

## 植被道路贴花等

- 树木渲染 Tree Rendering：Speed Tree 中间件
- 装饰物渲染 Decorator Rendering：面片 +LoDs
- 道路渲染 Road Rendering：Spline 样条线，根据 Spline 雕刻 Height Field，烘焙进 Virtual Texture
- 贴花渲染 Decal Rendering：烘焙进 Virtual Texture

## 大气散射理论

略

### 大气外观的经验建模 Analytic Atmosphere Appearance Modeling

公式略

优点：计算简单高效

缺点：
- 只适用于地面视角
- 大气参数无法自由调整，表现力不足

### 辐射转移方程 Radiative Transfer Equation（RTE）

光与大气中的参与介质交互分为四部分：

吸收 Absorption：
$$
- \sigma_a L(x,\omega) \quad ,\sigma_a \text{为吸收系数}
$$
外散射 Out-scattering：
$$
- \sigma_s L(x,\omega) \quad ,\sigma_s \text{为散射系数}
$$
自发光 Emission：（不常用）
$$
\sigma_a L_e(x,\omega)
$$
内散射 In-scattering：
$$
\sigma_s \int_{S^2} f_p(x,\omega, \omega')L(x,\omega') d\omega' \quad ,f_p \text{为相位函数}
$$
定义“消光系数”为：
$$
\sigma_t(x) = \sigma_a(x)+\sigma_s(x)
$$
于是得到辐射转移方程：
$$
dL(x,\omega)/dx = -\sigma_t L(x,\omega) + \sigma_a L_e(x,\omega) + \sigma_s \int_{S^2} f_p(x,\omega, \omega')L(x,\omega') d\omega'
$$

### 体积渲染方程 Volume Rendering Equation（VRE）

对于不透明表面上的一点 $M$，光线以方向角 $\omega$经过体积传播至摄像机：
$$
L(P,\omega) = \int_{x=0}^d T(x)[\sigma_a L_e(x,\omega) + \sigma_s L_i(x,\omega) + T(M)L(M,\omega)]
$$
其中：
$$
T(x)=e^{-\int_x^P \sigma_t(s)ds} \quad ,\text{Transmittance(通透度)：吸收和外散射导致的光线净减少因子}
$$
$$
L_i(x,\omega)= \int_{S^2} f_p(x,\omega, \omega')L(x,\omega') d\omega' \quad ,\text{内散射的净增加因子}
$$

### 散射类型 Scattering Types

瑞利散射 Rayleigh Scattering
- 光线向前与向后散射对称
- 短波长更易被散射

散射系数：
$$
\sigma_s^{Rayleigh}(\lambda,h)=\frac{8\pi^3(n^2-1)^2}{3} \frac{\rho(h)}{N} \frac{1}{\lambda^4} \quad ,N\text{为密度},\lambda\text{为波长}
$$
相位函数：
$$
F_{Rayleigh}(\theta)=\frac{3}{16\pi} (1+cos^2\theta)
$$
相乘化简，得到瑞利散射方程 Reyleigh Scattering Equation：
$$
S(\lambda,\theta,h)=\frac{\pi^2(n^2-1)^2}{2} \frac{\rho(h)}{N} \frac{1}{\lambda^4} (1+cos^2\theta)
$$

米氏散射 Mie Scattering
- 光线向前散射更多，向后散射更少
- 各种波长的光散射程度几乎相同

拟合方程，公式略 : (

![Pasted image 20220616150947](attachments/Pasted%20image%2020220616150947.png)

g>0 时为米氏散射，g<0 时光线更多向后散射，g=0 为瑞利散射

## 实时大气渲染

### Ray Marching 算法

思想：通过多次 Single Scattering 积分，计算空间中给定点的最终辐射度（radiance）

$$
L_{sun} \int_A^B S(\lambda,\theta,h) \cdot (T(\text{sun} \rightarrow P) + T(\text{sun} \rightarrow A))\text{d} s
$$

#### Precomputed Atmospheric Scattering

空间换时间的优化：

- Transmittance LUT，预计算通透度

$$
T(X_v \rightarrow X_m)=\frac{T(X_v \rightarrow B)}{T(X_m \rightarrow B)}
$$

![Pasted image 20220616204323](attachments/Pasted%20image%2020220616204323.png)

- Single Scattering LUT，预计算单次散射结果
	- 使用 3D Texture 存储 4D Table

![Pasted image 20220616204359](attachments/Pasted%20image%2020220616204359.png)

- 使用 Transmittance LUT 和 Single Scattering LUT，多次计算得到 Multiple Scattering LUT

![Pasted image 20220616204604](attachments/Pasted%20image%2020220616204604.png)

缺陷：
- 预计算开销大
- 动态天气环境变换困难
- 运行时开销依然不小（每个像素都对 4 维表进行插值）

前沿方法：A Scalable and Production Ready Sky and Atmosphere Rendering Technique, Epic Games

## 云的绘制

### 基于网格的云 Mesh-Based Cloud

没人这么做

### 面片云 Billboard Cloud

十几年前的游戏用这个

优点：
- 高效

缺点：
- 视觉效果很一般
- 云的类型受限制

### 体积云建模 Volumetric Cloud Modeling

3A 游戏常用的解决方案

优点：
- 云很真实
- 支持大面积的云层
- 支持动态天气
- 支持体积光照和体积阴影

缺点：
- 算法复杂
- 渲染开销昂贵

天气纹理 Weather Texture

噪声函数 Noise Functions
- 柏林噪声 Perlin Noise
- 细胞噪声 Worley（Voronoi）Noise

云密度模型 Cloud Density Model
- 思想：用一张纹理图 Texture 限定云的范围和云的高度，用各种频率的噪声作为遮罩，得到云的形态

使用 Ray Marching 渲染云 Rendering Cloud by Ray Marching
- 由于云的通透度很低，可以作大量假设，简化计算